C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5C51\C51\BIN\C51.EXE app\main.c LARGE OPTIMIZE(0,SPEED) BROWSE MODC2 INCDIR(.\app;.\base) DE
                    -BUG OBJECTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <SN8F5708.h>
   2          #include <intrins.h>
   3          #include "adzh_10.h"
   4          #include "PID_operation.h"
   5          #include "ISP.h"
   6          #include "getkey.h"
   7          #include "delay.h"
   8          #include "lcd.h"
   9          #include "tmr.h"
  10          #include "lcd.h"
  11          #include "definition.h"
  12          #include "gpio.h"
  13          #include "PWM.h"
  14          #include "EC11.h"
  15          
  16          void Run_Air_Handle(void);
  17          void Run_Sol_Handle(void);
  18          uint16_t Read_Air_Adc();
  19          uint16_t Read_Sol_Adc();
  20          void start_init(void);
  21          void Air_Speed_Handle(void);
  22          void Disp_Handle(void);
  23          void Check_Mode_Handle(void);
  24          void Key_Handle(void);
  25          void Save_Data_Handle(void);
  26          uint16_t EC_Handle(uint16_t in_fan);
  27          uint8_t check_sol_work_mode(uint8_t in_Mode);
  28          uint8_t check_air_work_mode(uint8_t in_mode);
  29          void Check_Error_Air(uint16_t in_err_data);
  30          void Check_Error_Sol(uint16_t in_err_data);
  31          void wd16z8(uint16_t in_16data, uint8_t wn);
  32          uint16_t rd8z16(uint8_t rdin_i);
  33          uint16_t Pid_Control_Air(uint16_t Set_data, uint16_t Cur_data);
  34          uint16_t Pid_Control_Sol(uint16_t Set_dat, uint16_t Cur_dat);
  35          void Disp_Pid_Hot_Sol(uint16_t in_hot);
  36          void Disp_Pid_Hot_Air(uint16_t in_hot);
  37          uint8_t panduan_pid_mode(int pd_aa, pd_ab, in_hot);
  38          void Sleep_Air_Handle(void);
  39          void Sleep_Sol_Handle(void);
  40          void Close_Air_Handle(void);
  41          void Close_Sol_Handle(void);
  42          
  43          void main(void)
  44          {
  45   1          CKCON = 0x70;
  46   1          CLKSEL = 0x07; // Fcpu = 16M
  47   1          CLKCMD = 0x69; // Clock switch start
  48   1          WDTR = 0x5A;
  49   1      
  50   1          gpio_init();
  51   1          InitT0();
  52   1          PWM1_init();
  53   1          PWM2_init();
  54   1          PWM3_init();
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 2   

  55   1              AIR_HOT_KEY = 1;
  56   1          start_init_flag = 1;
  57   1          end_init_flag = 0;
  58   1          init_outtime = 0;
  59   1          Sol_restart_flag = 1;
  60   1          Air_restart_flag = 1;
  61   1          ISPpageread2(); // read rom
  62   1              P46 = 0;
  63   1              P50 = 0;
  64   1          while (1)
  65   1          {
  66   2              WDTR = 0x5A;
  67   2              if (start_init_flag == falsh)
  68   2              {
  69   3                  /* 风枪部分 */
  70   3                  if (Air_Work_Mode == RUN)
  71   3                  {
  72   4                      Run_Air_Handle();
  73   4                  }
  74   3                  else if (Air_Work_Mode == SLEEP)
  75   3                  {
  76   4                      Sleep_Air_Handle();
  77   4                  }
  78   3                  else if (Air_Work_Mode == CLOSE)
  79   3                  {
  80   4                      Close_Air_Handle();
  81   4                  }
  82   3      
  83   3                  /* 烙铁部分 */
  84   3                  if (Sol_Work_Mode == RUN)
  85   3                  {
  86   4                      Run_Sol_Handle();
  87   4                  }
  88   3                  else if (Sol_Work_Mode == SLEEP)
  89   3                  {
  90   4                      Sleep_Sol_Handle();
  91   4                  }
  92   3                  else if (Sol_Work_Mode == CLOSE)
  93   3                  {
  94   4                      Close_Sol_Handle();
  95   4                  }
  96   3              }
  97   2              else
  98   2                  start_init(); // 初始化
  99   2              switch (main_cycle)
 100   2              {
 101   3              case 1:
 102   3                  /* check work mode */
 103   3                  Check_Mode_Handle();
 104   3      
 105   3                  break;
 106   3              case 2:
 107   3                  /* Error check*/
 108   3      #if 0
                          Check_Error_Handle();
              #endif
 111   3                  break;
 112   3              case 3:
 113   3                  /* Disp_handle*/
 114   3                  Disp_Handle();
 115   3                  break;
 116   3              case 4:
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 3   

 117   3                  /* AIR_SPEED */
 118   3                  Air_Speed_Handle();
 119   3                  break;
 120   3              default:main_cycle = 0x00;
 121   3                  break;
 122   3              }
 123   2              main_cycle++;
 124   2              if (Key_Cycle_Times == 0)
 125   2              {
 126   3                  Key_Cycle_Times = 0x03;
 127   3                  Key_Handle();
 128   3              }
 129   2              Air_speed_data = EC_Handle(Air_speed_data);
 130   2          }
 131   1      }
 132          
 133          void Sleep_Air_Handle(void)
 134          {
 135   1          if (Air_Sleep_Mode == AUTO) // 立刻休眠 100度显示--- 70度关风枪
 136   1          {
 137   2                      Last_Air_Sleep_Mode = AUTO;
 138   2                      PWM2_Off();
 139   2              Air_pid_outdata = 0;
 140   2                      pid_mode_air = 0;
 141   2              AIR_HOT_KEY = 1; // 关
 142   2                      
 143   2              Air_real_temp_data = Read_Air_Adc();
 144   2              if (Air_real_temp_data < 100)
 145   2              {
 146   3                  if (Air_real_temp_data < 70)
 147   3                  {
 148   4                      PWM3_out(0);
 149   4                      Disp_Number_Air_Speed = DISP_SLEEP;
 150   4                      Disp_Renew_Flag_Fan = on;
 151   4                  }
 152   3                  Air_sleep_flag = on;
 153   3                  if (Key_Ent_flag == off)
 154   3                  {
 155   4                      Disp_Number_Air = DISP_SLEEP;
 156   4                      Disp_Renew_Flag_Air = on;
 157   4                      Disp_Number_Air_Speed = DISP_SLEEP;
 158   4                      Disp_Renew_Flag_Fan = on;
 159   4                  }
 160   3              }
 161   2              else
 162   2              {
 163   3                              PWM3_out(0xff);
 164   3                  Air_sleep_flag = off;
 165   3                  if (Key_Ent_flag == off)
 166   3                  {
 167   4                      if (CF_flag == 1)
 168   4                          Disp_Number_Air = DISP_REALTEMP_Fahrenheit;
 169   4                      else
 170   4                          Disp_Number_Air = DISP_REALTEMP;
 171   4                      Disp_Renew_Flag_Air = on;
 172   4                      Disp_Number_Air_Speed = DISP_SLEEPING;
 173   4                      Disp_Renew_Flag_Fan = on;
 174   4                  }
 175   3              }
 176   2          }
 177   1          else if (Air_Sleep_Mode == MANUAL) // 不休眠
 178   1          {
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 4   

 179   2                      if(Last_Air_Sleep_Mode == AUTO)
 180   2                      {
 181   3                              pid_mode_air = 0;
 182   3                              start_init_flag = 1;
 183   3                      }
 184   2                      Last_Air_Sleep_Mode = MANUAL;
 185   2              Disp_Number_Air_Speed = DISP_WORK;
 186   2              Disp_Renew_Flag_Fan = on;
 187   2              Run_Air_Handle();
 188   2          }
 189   1      }
 190          void Sleep_Sol_Handle(void)
 191          {
 192   1              PWM1_Off();
 193   1              Sol_pid_outdata = 0;
 194   1              pid_mode_sol = 0;
 195   1              Sol_real_temp_data = Read_Sol_Adc();
 196   1              if (Sol_real_temp_data < 200) // 休眠
 197   1              {
 198   2                      Sleep_Sol_Flag = on;
 199   2                      Disp_Number_Sol = DISP_SLEEP;
 200   2                      Disp_Renew_Flag_Sol = on;
 201   2              }
 202   1              else
 203   1              {
 204   2                      Sleep_Sol_Flag = off;
 205   2                      if (Key_Ent_flag == off)
 206   2                      {
 207   3                              if (CF_flag == 1)
 208   3                                      Disp_Number_Sol = DISP_REALTEMP_Fahrenheit;
 209   3                              else
 210   3                                      Disp_Number_Sol = DISP_REALTEMP;
 211   3                              Disp_Renew_Flag_Sol = on;
 212   3                      }
 213   2              }
 214   1      
 215   1      }
 216          void Close_Air_Handle(void)
 217          {
 218   1          PWM2_Off();
 219   1          Air_pid_outdata = 0;
 220   1              pid_mode_air = 0;
 221   1          AIR_HOT_KEY = 1;
 222   1          Air_real_temp_data = Read_Air_Adc();
 223   1          if (Air_real_temp_data < 100) // 关风
 224   1              PWM3_out(0);
 225   1          Close_Sol_Flag = on;
 226   1          Disp_Number_Air = DISP_OFF;
 227   1          Disp_Number_Air_Speed = DISP_OFF;
 228   1          Disp_Renew_Flag_Fan = on;
 229   1          Disp_Renew_Flag_Air = on;
 230   1          Cycle_Times_Disp_Air = 0x00;
 231   1      }
 232          void Close_Sol_Handle(void)
 233          {
 234   1              PWM1_Off();
 235   1          Sol_pid_outdata = 0;
 236   1              pid_mode_sol = 0;
 237   1          Close_Sol_Flag = on;
 238   1          Disp_Number_Sol = DISP_OFF;
 239   1          Disp_Renew_Flag_Sol = on;
 240   1          Cycle_Times_Disp_Sol = 0x00;
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 5   

 241   1      
 242   1      }
 243          void Run_Air_Handle(void)
 244          {
 245   1          if (error_air_flag == falsh)
 246   1          {
 247   2              if (Air_PID_Cycle_Time == 0)
 248   2              {
 249   3                  Air_PID_Cycle_Time = 0x03;
 250   3                  Air_real_temp_data = Pid_Control_Air(Air_set_temp_data, Air_real_temp_data);
 251   3                  Disp_Pid_Hot_Air(Air_real_temp_data);
 252   3              }
 253   2          }
 254   1          else
 255   1              error_air_data = Read_Air_Adc();
 256   1      }
 257          
 258          void Run_Sol_Handle(void)
 259          {
 260   1          if (error_sol_flag == falsh)
 261   1          {
 262   2              if (Sol_PID_Cycle_Time == 0)
 263   2              {
 264   3                  Sol_PID_Cycle_Time = 0x03;
 265   3                  Sol_real_temp_data = Pid_Control_Sol(Sol_set_temp_data, Sol_real_temp_data);
 266   3                  Disp_Pid_Hot_Sol(Sol_real_temp_data);
 267   3              }
 268   2          }
 269   1          else
 270   1              error_sol_data = Read_Sol_Adc();
 271   1      }
 272          
 273          void Disp_Pid_Hot_Air(uint16_t in_hot)
 274          {
 275   1          if (set_flag == off && Key_Ent_flag == off)
 276   1          {
 277   2              if (disp_gate == off)
 278   2              {
 279   3                  if (CF_flag == 1)
 280   3                  {
 281   4                      Disp_Number_Air = DISP_REALTEMP_Fahrenheit;
 282   4                  }
 283   3                  else
 284   3                  {
 285   4                      Disp_Number_Air = DISP_REALTEMP;
 286   4                  }
 287   3                  Disp_Number_Air_Speed = DISP_WORK;
 288   3                  Disp_Renew_Flag_Fan = on;
 289   3                  Disp_Renew_Flag_Air = on;       
 290   3                      }
 291   2              else
 292   2              {
 293   3                  if (pid_hot == panduan_pid_mode(Air_set_temp_data, in_hot, 10))
 294   3                  {
 295   4                      if (CF_flag == 1)
 296   4                          Disp_Number_Air = DISP_SETTEMP_Fahrenheit;
 297   4                      else
 298   4                          Disp_Number_Air = DISP_SETTEMP;
 299   4                  }
 300   3                  else
 301   3                  {
 302   4                      if (CF_flag == 1)
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 6   

 303   4                          Disp_Number_Air = DISP_REALTEMP_Fahrenheit;
 304   4                      else
 305   4                          Disp_Number_Air = DISP_REALTEMP;
 306   4                  }
 307   3                  Disp_Number_Air_Speed = DISP_WORK;
 308   3                  Disp_Renew_Flag_Fan = on;
 309   3                  Disp_Renew_Flag_Air = on;
 310   3              }
 311   2          }
 312   1      }
 313          
 314          void Disp_Pid_Hot_Sol(uint16_t in_hot)
 315          {
 316   1          if (set_flag == off && Key_Ent_flag == off)
 317   1          {
 318   2              if (disp_gate == off)
 319   2              {
 320   3                  if (CF_flag == 1)
 321   3                  {
 322   4                      Disp_Number_Sol = DISP_REALTEMP_Fahrenheit;
 323   4                  }
 324   3                  else
 325   3                  {
 326   4                      Disp_Number_Sol = DISP_REALTEMP;
 327   4                  }
 328   3                  Disp_Renew_Flag_Sol = on;
 329   3              }
 330   2              else
 331   2              {
 332   3                  if (pid_hot == panduan_pid_mode(Air_set_temp_data, in_hot, 10))
 333   3                  {
 334   4                      if (CF_flag == 1)
 335   4                          Disp_Number_Sol = DISP_SETTEMP_Fahrenheit;
 336   4                      else
 337   4                          Disp_Number_Sol = DISP_SETTEMP;
 338   4                  }
 339   3                  else
 340   3                  {
 341   4                      if (CF_flag == 1)
 342   4                          Disp_Number_Sol = DISP_REALTEMP_Fahrenheit;
 343   4                      else
 344   4                          Disp_Number_Sol = DISP_REALTEMP;
 345   4                  }
 346   3                  Disp_Renew_Flag_Sol = on;
 347   3              }
 348   2          }
 349   1      }
 350          
 351          uint16_t Pid_Control_Air(uint16_t Set_data, uint16_t Cur_data)
 352          {
 353   1          uint16_t hot_data_air = Cur_data;
 354   1          hot_data_air = Read_Air_Adc();
 355   1          if (pid_mode_air == pid_hot)
 356   1          {
 357   2              hot_data_air += Air_cal_data;
 358   2              Air_pid_outdata = PID_operation_Air(Set_data, hot_data_air);
 359   2          }
 360   1          else
 361   1          {
 362   2              pid_mode_air = panduan_pid_mode(Set_data, hot_data_air, 20);
 363   2              if (pid_mode_air == add_hot)
 364   2                  Air_pid_outdata = 5000;
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 7   

 365   2              else if (pid_mode_air == sub_hot)
 366   2                  Air_pid_outdata = 0;
 367   2          }
 368   1          return hot_data_air;
 369   1      }
 370          
 371          uint16_t Pid_Control_Sol(uint16_t Set_dat, uint16_t Cur_dat)
 372          {
 373   1          uint16_t hot_data_sol = Cur_dat;
 374   1          hot_data_sol = Read_Sol_Adc();
 375   1          if (pid_mode_sol == pid_hot)
 376   1          {
 377   2              hot_data_sol += Sol_cal_data;
 378   2              Sol_pid_outdata = PID_operation_Sol(Set_dat, hot_data_sol);
 379   2          }
 380   1          else
 381   1          {
 382   2              pid_mode_sol = panduan_pid_mode(Set_dat, hot_data_sol, 20);
 383   2              if (pid_mode_sol == add_hot)
 384   2                  Sol_pid_outdata = 5000;
 385   2              else if (pid_mode_sol == sub_hot)
 386   2                  Sol_pid_outdata = 0;
 387   2          }
 388   1          return hot_data_sol;
 389   1      }
 390          
 391          uint8_t panduan_pid_mode(int pd_aa, pd_ab, in_hot)
 392          {
 393   1          int pad_coe;
 394   1          pad_coe = (pd_aa - pd_ab);
 395   1          if (pad_coe > in_hot)
 396   1              return add_hot;
 397   1          else if (pad_coe < -in_hot)
 398   1              return sub_hot;
 399   1          else
 400   1              return pid_hot;
 401   1      }
 402          
 403          uint16_t Read_Air_Adc()
 404          {
 405   1          uint16_t out_data_air = 0x00;
 406   1          PWM2_Off();
 407   1          Delay_X10Us(20);
 408   1          out_data_air = adc_value_10(1);
 409   1          PWM2_Open();
 410   1          return out_data_air;
 411   1      }
 412          
 413          uint16_t Read_Sol_Adc()
 414          {
 415   1          uint16_t out_data_sol = 0x00;
 416   1          PWM1_Off();
 417   1          Delay_X10Us(20);
 418   1          out_data_sol = adc_value_10(2);
 419   1          PWM1_Open();
 420   1          return out_data_sol;
 421   1      }
 422          
 423          uint16_t EC_Handle(uint16_t in_fan)
 424          {
 425   1          uint8_t fan_ec = 0;
 426   1          uint16_t ec_outdata = in_fan;
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 8   

 427   1          fan_ec = ec11_ve();
 428   1          if (fan_ec == 'Y')
 429   1          {
 430   2              Ec_ent_flag = on;
 431   2              if (Ec_Cycle_Times != 0)
 432   2                  ec_outdata += 10;
 433   2              else
 434   2                  ec_outdata++;
 435   2              if (ec_outdata > 99)
 436   2                  ec_outdata = 99;
 437   2              Updata_Air_Speed_Flag = on; // 风量更新
 438   2              Disp_Number_Air_Speed = DISP_WORK;
 439   2              Disp_Renew_Flag_Fan = on;
 440   2              Ec_End_Times = 0x20;
 441   2              Ec_Cycle_Times = 0x20;
 442   2          }
 443   1          else if (fan_ec == 'Z')
 444   1          {
 445   2              Ec_ent_flag = on;
 446   2              if (Ec_Cycle_Times != 0)
 447   2                  ec_outdata -= 10;
 448   2              else
 449   2                  ec_outdata--;
 450   2              if (ec_outdata < 10)
 451   2                  ec_outdata = 10;
 452   2              Updata_Air_Speed_Flag = on; // 风量更新
 453   2              Disp_Number_Air_Speed = DISP_WORK;
 454   2              Disp_Renew_Flag_Fan = on;
 455   2              Ec_End_Times = 0x20;
 456   2              Ec_Cycle_Times = 0x20;
 457   2          }
 458   1          else if (Ec_ent_flag == on && Ec_End_Times == 0x00)
 459   1          {
 460   2              Ec_ent_flag = off;
 461   2              if (Air_sleep_flag == on)
 462   2                  Disp_Number_Air_Speed = DISP_SLEEP;
 463   2              else
 464   2                  Disp_Number_Air_Speed = DISP_WORK;
 465   2              Disp_Renew_Flag_Fan = on;
 466   2              Save_Data_Handle();
 467   2          }
 468   1          return ec_outdata;
 469   1      }
 470          
 471          void Disp_Handle(void)
 472          {
 473   1          if (set_flag == on)
 474   1          {
 475   2              Disp_Set_Handle( First_menu_number);
 476   2          }
 477   1          else
 478   1          {
 479   2              if (Disp_Renew_Flag_Air == on && Cycle_Times_Disp_Air == 0x00)
 480   2              {
 481   3                  Disp_Renew_Flag_Air = off;
 482   3                  Cycle_Times_Disp_Air = 0x0a;
 483   3                  Disp_Air_Handle(Disp_Number_Air);
 484   3              }
 485   2              if (Disp_Renew_Flag_Sol == on && Cycle_Times_Disp_Sol == 0x00)
 486   2              {
 487   3                  Disp_Renew_Flag_Sol = off;
 488   3                  Cycle_Times_Disp_Sol = 0x0a;
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 9   

 489   3                  Disp_Sol_Handle(Disp_Number_Sol);
 490   3              }
 491   2              if (Disp_Renew_Flag_Fan == on)
 492   2              {
 493   3                  Disp_Renew_Flag_Fan = off;
 494   3                  Disp_Fan_Handle(Disp_Number_Air_Speed);
 495   3              }
 496   2          }
 497   1      }
 498          
 499          void Check_Mode_Handle(void)
 500          {
 501   1          Air_Work_Mode = check_air_work_mode(Air_Work_Mode);
 502   1          Sol_Work_Mode = check_sol_work_mode(Sol_Work_Mode);
 503   1      }
 504          
 505          uint8_t check_air_work_mode(uint8_t in_mode)
 506          {
 507   1          uint8_t out_mode = in_mode;
 508   1          if (Air_Check_OffOn == 1)
 509   1          {
 510   2              // 风枪开关检测
 511   2              Air_Off_Sum++;
 512   2              Air_Run_Sum = 0;
 513   2              Air_Slp_Sum = 0;
 514   2              if (Air_Off_Sum > 3)
 515   2              {
 516   3                  Air_Off_Sum = 0;
 517   3                  out_mode = CLOSE;
 518   3              }
 519   2          }
 520   1          else if (Air_Check_Sleep == 0)
 521   1          {
 522   2              // 风枪睡眠检测
 523   2              Air_Slp_Sum++;
 524   2              Air_Run_Sum = 0;
 525   2              Air_Off_Sum = 0;
 526   2              if (Air_Slp_Sum > 3)
 527   2              {
 528   3                  Air_Slp_Sum = 0;
 529   3                  out_mode = SLEEP;
 530   3              }
 531   2          }
 532   1          else if (Air_Check_Sleep == 1)
 533   1          {
 534   2              // 风枪运行检测
 535   2              Air_Run_Sum++;
 536   2              Air_Off_Sum = 0;
 537   2              Air_Slp_Sum = 0;
 538   2              if (Air_Run_Sum > 1)
 539   2              {
 540   3                  if (out_mode == CLOSE || out_mode == SLEEP)
 541   3                  {
 542   4                      start_init_flag = 1;
 543   4                      Air_restart_flag = 1;
 544   4                  }
 545   3                  Air_Run_Sum = 0;
 546   3                  out_mode = RUN;
 547   3              }
 548   2          }
 549   1          return out_mode;
 550   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 10  

 551          
 552          uint8_t check_sol_work_mode(uint8_t in_Mode)
 553          {
 554   1          uint8_t out_Mode = in_Mode;
 555   1          if (Sol_Check_OffOn == 1)
 556   1          {
 557   2              // 烙铁开关检测
 558   2              Sol_Off_Sum++;
 559   2              Sol_Run_Sum = 0;
 560   2              Sol_Slp_Sum = 0;
 561   2              if (Sol_Off_Sum > 3)
 562   2              {
 563   3                  Sol_Off_Sum = 0;
 564   3                  out_Mode = CLOSE;
 565   3                              Sol_Sleep_Ready_Flag = off;
 566   3              }
 567   2          }
 568   1              else
 569   1              {
 570   2                      if(out_Mode == CLOSE )
 571   2                      {
 572   3                              start_init_flag = 1;
 573   3                              Sol_restart_flag = 1;
 574   3                      }
 575   2                      if(set_sleep_time == 0x00)  //不休眠
 576   2                      {
 577   3                              out_Mode = RUN;
 578   3                              Sol_Off_Sum = 0;
 579   3                              Sol_Slp_Sum = 0;
 580   3                              Sol_Run_Sum = 0;
 581   3                              Sol_Sleep_Ready_Flag = off;
 582   3                      }
 583   2                      else
 584   2                      {
 585   3                              if(Sol_Sleep_Time != 0x00)  //工作才要休眠
 586   3                              {
 587   4                                      out_Mode = RUN;
 588   4                                      if (Sol_Check_Sleep == 1)  //休眠
 589   4                                      {
 590   5                                              Sol_Slp_Sum++;
 591   5                                              Sol_Off_Sum = 0;
 592   5                                              if(Sol_Slp_Sum > 10)
 593   5                                              {
 594   6                                                      Sol_Sleep_Ready_Flag = on;  //烙铁休眠准备标志 开始休眠计时
 595   6                                                      Sol_Slp_Sum = 0;
 596   6                                                      Sol_Run_Sum = 0;
 597   6                                              }
 598   5                                      }
 599   4                              }
 600   3                              else   //休眠才要唤醒
 601   3                              {
 602   4                                      out_Mode = SLEEP;
 603   4                                      if (Sol_Check_Sleep == 0)  //唤醒
 604   4                                      {
 605   5                                              Sol_Run_Sum++;
 606   5                                              Sol_Off_Sum = 0;
 607   5                                              Sol_Slp_Sum = 0;
 608   5      //                                      if(Sol_Run_Sum > 1)
 609   5      //                                      {
 610   5                                                      Sol_Sleep_Time = set_sleep_time;
 611   5                                                      out_Mode = RUN;
 612   5                                                      Sol_Run_Sum = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 11  

 613   5                                                      Sol_Sleep_Ready_Flag = off;
 614   5      //                                      }
 615   5                                      }
 616   4                              }
 617   3                      }
 618   2              }
 619   1          return out_Mode;
 620   1      }
 621          
 622          void Check_Error_Handle(void)
 623          {
 624   1          Check_Error_Air(error_air_data);
 625   1          Check_Error_Sol(error_sol_data);
 626   1      }
 627          
 628          void Check_Error_Air(uint16_t in_err_data)
 629          {
 630   1          // 风枪错误检测
 631   1          if (Cycle_Times_Error == 0)
 632   1          {
 633   2              if ((end_init_flag == 0) && (in_err_data < 70)) //????
 634   2              {
 635   3                  if (Min_Sum_Air == 0)
 636   3                  {
 637   4                      error_air_flag = 1;
 638   4                                      PWM2_Off();
 639   4                      Air_pid_outdata = 0;
 640   4                      AIR_HOT_KEY = 1;
 641   4                      Error_num_Air = 1;
 642   4                      if (Key_Ent_flag == off)
 643   4                      {
 644   5                          Disp_Number_Air = DISP_ERR;
 645   5                          Disp_Renew_Flag_Air = on;
 646   5                      }
 647   4                      Min_Sum_Air = 20;
 648   4                  }
 649   3                  else
 650   3                      Min_Sum_Air--;
 651   3              }
 652   2              else if (in_err_data > 580) //????
 653   2              {
 654   3                  if (Max_Sum_Air == 0)
 655   3                  {
 656   4                      error_air_flag = 1;
 657   4                      AIR_HOT_KEY = 1; // 先停止加热 温度下降后再关风
 658   4                      PWM2_Off();
 659   4                      Air_pid_outdata = 0;
 660   4                      Error_num_Air = 2;
 661   4                      if (Key_Ent_flag == off)
 662   4                      {
 663   5                          Disp_Number_Air = DISP_ERR;
 664   5                          Disp_Renew_Flag_Air = on;
 665   5                      }
 666   4                      Max_Sum_Air = 3;
 667   4                  }
 668   3                  else
 669   3                      Max_Sum_Air--;
 670   3              }
 671   2              Cycle_Times_Error = 0x02;
 672   2          }
 673   1      }
 674          
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 12  

 675          void Check_Error_Sol(uint16_t in_err_data)
 676          {
 677   1          // 烙铁错误检测
 678   1          if (Cycle_Times_Error == 0)
 679   1          {
 680   2              if ((end_init_flag == 0) && (in_err_data < 70)) //????
 681   2              {
 682   3                  if (Min_Sum_Sol == 0)
 683   3                  {
 684   4                      error_sol_flag = 1;
 685   4                      PWM1_Off();
 686   4                      Sol_pid_outdata = 0;
 687   4                      Error_num_Sol = 1;
 688   4                      if (Key_Ent_flag == off)
 689   4                      {
 690   5                          Disp_Number_Sol = DISP_ERR;
 691   5                          Disp_Renew_Flag_Sol = on;
 692   5                      }
 693   4                      Min_Sum_Sol = 20;
 694   4                  }
 695   3                  else
 696   3                      Min_Sum_Sol--;
 697   3              }
 698   2              else if (in_err_data > 580) //????
 699   2              {
 700   3                  if (Max_Sum_Sol == 0)
 701   3                  {
 702   4                      error_sol_flag = 1;
 703   4                      PWM1_Off();
 704   4                      Sol_pid_outdata = 0;
 705   4                      Error_num_Sol = 2;
 706   4                      if (Key_Ent_flag == off)
 707   4                      {
 708   5                          Disp_Number_Sol = DISP_ERR;
 709   5                          Disp_Renew_Flag_Sol = on;
 710   5                      }
 711   4                      Max_Sum_Sol = 3;
 712   4                  }
 713   3                  else
 714   3                      Max_Sum_Sol--;
 715   3              }
 716   2              Cycle_Times_Error = 0x02;
 717   2          }
 718   1      }
 719          
 720          void Air_Speed_Handle(void)
 721          {
 722   1          uint16_t pwm_out = 0x00;
 723   1              if (Updata_Air_Speed_Flag == 1)
 724   1              {
 725   2                      Updata_Air_Speed_Flag = 0;
 726   2                      pwm_out = Air_speed_data * 2.2 + 30;
 727   2                      if (pwm_out > 0xff)
 728   2                              pwm_out = 0xff;
 729   2                      PWM3_out(pwm_out);
 730   2              }
 731   1      }
 732          void start_init(void)
 733          {
 734   1          if (start_init_flag == 1 && end_init_flag == 0)
 735   1          {
 736   2              PWM_ALL_OFF(); // 关闭全部PWM通道
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 13  

 737   2                      PWM3_out(66);
 738   2              PID_Init_Sol();
 739   2              PID_Init_Air();
 740   2              CF_flag = u8_data[0];
 741   2              CF_flag = 0;
 742   2              set_cf_flag = CF_flag;
 743   2              disp_gate = u8_data[2];
 744   2      //        disp_gate = 0;
 745   2                      speak_gate = u8_data[3];
 746   2              Air_speed_data =  rd8z16(14);
 747   2              if (Air_speed_data > 99)
 748   2                  Air_speed_data = 50;
 749   2              else if (Air_speed_data < 0)
 750   2                  Air_speed_data = 50;
 751   2      
 752   2              Air_cal_data = rd8z16(4);
 753   2              Sol_cal_data = rd8z16(6);
 754   2              if (Air_cal_data > 99)
 755   2                  Air_cal_data = 0;
 756   2              else if (Air_cal_data < 0)
 757   2                  Air_cal_data = 0;
 758   2              if (Sol_cal_data > 99)
 759   2                  Sol_cal_data = 0;
 760   2              else if (Sol_cal_data < 0)
 761   2                  Sol_cal_data = 0;
 762   2      
 763   2              Air_set_temp_data = rd8z16(8);
 764   2              Sol_set_temp_data = rd8z16(10);
 765   2              if (Air_set_temp_data > 500)
 766   2                  Air_set_temp_data = 300;
 767   2              else if (Air_set_temp_data < 0)
 768   2                  Air_set_temp_data = 300;
 769   2              if (Sol_set_temp_data > 500)
 770   2                  Sol_set_temp_data = 300;
 771   2              else if (Sol_set_temp_data < 0)
 772   2                  Sol_set_temp_data = 300;
 773   2      
 774   2              if (CF_flag == 1)
 775   2              {
 776   3                  sol_key_data = ((Sol_set_temp_data * 9 / 5) + 32);
 777   3                  air_key_data = ((Air_set_temp_data * 9 / 5) + 32);
 778   3              }
 779   2              else
 780   2              {
 781   3                  sol_key_data = Sol_set_temp_data;
 782   3                  air_key_data = Air_set_temp_data;
 783   3              }
 784   2              sol_set_cal_data = sol_key_data;
 785   2              air_set_cal_data = air_key_data;
 786   2              set_sleep_time = rd8z16(12);
 787   2              if (set_sleep_time < 0 || set_sleep_time > 99)
 788   2                  set_sleep_time = 1;  //默认五分钟休眠
 789   2              Sol_Sleep_Time = set_sleep_time;
 790   2      
 791   2                      pid_mode_air = 0;
 792   2                      pid_mode_sol = 0;
 793   2              Error_num_Air = 0; // 风枪错误代码
 794   2              Error_num_Sol = 0; // 烙铁错误代码
 795   2              Error_num_Air = 0;
 796   2              Error_num_Sol = 0;
 797   2              Min_Sum_Air = 20;
 798   2              Max_Sum_Air = 4;
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 14  

 799   2              Min_Sum_Sol = 20;
 800   2              Max_Sum_Sol = 4;
 801   2              key_out_time = 0;
 802   2              menu_level = 1;
 803   2              First_menu_number = 1;
 804   2              Second_menu_number = 1;
 805   2                      Sol_Sleep_Ready_Flag = 0;
 806   2                      Check_Mode_Handle();
 807   2                      Updata_Air_Speed_Flag = on;
 808   2              if (Air_restart_flag == on)
 809   2              {
 810   3      //            Air_Work_Mode = RUN; // 风枪工作模式
 811   3                  Air_restart_flag = off;
 812   3                  
 813   3                  Disp_Renew_Flag_Air = on;
 814   3                  Cycle_Times_Disp_Air = 0x00;
 815   3                  Disp_Renew_Flag_Fan = on;
 816   3                  Disp_Number_Air_Speed = DISP_WORK;
 817   3                  Disp_Number_Air = DISP_SETTEMP;
 818   3              }
 819   2              if (Sol_restart_flag == on)
 820   2              {
 821   3      //            Sol_Work_Mode = RUN; // 烙铁工作模式
 822   3                  Sol_restart_flag = off;
 823   3                  Disp_Renew_Flag_Sol = on;
 824   3                  Cycle_Times_Disp_Sol = 0x00;
 825   3                  Disp_Number_Sol = DISP_SETTEMP;
 826   3              }
 827   2                      if(Air_Work_Mode == CLOSE)
 828   2                      {
 829   3                              Disp_Number_Air = DISP_OFF;
 830   3                               Disp_Number_Air_Speed = DISP_OFF;
 831   3                      }
 832   2                      if(Sol_Work_Mode == CLOSE)
 833   2                      {
 834   3                              Disp_Number_Sol = DISP_OFF;
 835   3                      }
 836   2              set_flag = 0;
 837   2              AIR_HOT_KEY = 1; // 不加热
 838   2              init_outtime = 0x0a;
 839   2              end_init_flag = 1;
 840   2          }
 841   1          else if (end_init_flag == 1 && init_outtime == 0x00)
 842   1          {
 843   2              PWM_ALL_OPEN();
 844   2              start_init_flag = 0;
 845   2              end_init_flag = 0;
 846   2              AIR_HOT_KEY = 0; // 加热
 847   2          }
 848   1      }
 849          
 850          void Key_Handle(void)
 851          {
 852   1          uint8_t key_value;
 853   1          key_value = get_key();
 854   1          if (inkey_number == key_set) //  设置界面
 855   1          {
 856   2              switch (key_value)
 857   2              {
 858   3              case (keydown_ent):
 859   3                  break;
 860   3              case (keyup_ent):
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 15  

 861   3              {
 862   4                  Key_Ent_flag = on;
 863   4                  inkey_number = key_null;
 864   4                  longkey_flag = 0;
 865   4              }
 866   3              break;
 867   3              case (key_long):
 868   3                  break;
 869   3              case (key_continue):
 870   3              {
 871   4                  if (longkey_flag == 0)
 872   4                  {
 873   5                      longkey_flag = 1;
 874   5                      Key_Ent_flag = on;
 875   5                      if (set_flag == 0) // 打开设置界面
 876   5                      {
 877   6                          set_flag = 1;
 878   6                          menu_level = 1;         // 一级菜单
 879   6                          First_menu_number = 0;  // 一级菜单序号
 880   6                          Second_menu_number = 0; // 二级菜单序号
 881   6                          key_out_time = 100;     // 设置界面退出时间
 882   6                      }
 883   5                      else
 884   5                      {
 885   6                          set_flag = 0; // 关闭设置界面
 886   6                          key_out_time = 0;
 887   6                      }
 888   5                  }
 889   4              }
 890   3              break;
 891   3              default:
 892   3                  break;
 893   3              }
 894   2          }
 895   1          else if (inkey_number == key_air_up)
 896   1          {
 897   2              switch (key_value)
 898   2              {
 899   3              case (keydown_ent):
 900   3                  break;
 901   3              case (keyup_ent):
 902   3              {
 903   4                  Key_Ent_flag = on;
 904   4                  if (set_flag == 0) // 非设置界面
 905   4                  {
 906   5                      air_key_data++;
 907   5                      if (air_key_data > 500)
 908   5                          air_key_data = 500;
 909   5                      Disp_Number_Air = DISP_SETTEMP;
 910   5                      Disp_Renew_Flag_Air = on;
 911   5                      Cycle_Times_Disp_Air = 0x00;
 912   5                      key_out_time = 0x30;
 913   5                  }
 914   4                  else
 915   4                  {
 916   5                      First_menu_number++;
 917   5                      if (First_menu_number > 6)
 918   5                          First_menu_number = 0;
 919   5                                      if(First_menu_number == 1)
 920   5                                      {
 921   6                                              if(CF_flag == 1 || set_cf_flag == 1)
 922   6                                                      air_set_cal_data = (Air_set_temp_data * 9 / 5) + 32;
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 16  

 923   6                                              else if(CF_flag == 0 || set_cf_flag == 0)
 924   6                                                      air_set_cal_data = Air_set_temp_data;
 925   6                                      }
 926   5                                      if(First_menu_number == 2)
 927   5                                      {
 928   6                                              if(CF_flag == 1 || set_cf_flag == 1)
 929   6                                                      sol_set_cal_data = (Sol_set_temp_data * 9 / 5) + 32;
 930   6                                              else if(CF_flag == 0 || set_cf_flag == 0)
 931   6                                                      sol_set_cal_data = Sol_set_temp_data;
 932   6                                      }
 933   5                      key_out_time = 0x50;
 934   5                  }
 935   4                  inkey_number = key_null;
 936   4              }
 937   3              break;
 938   3              case (key_long):
 939   3                  break;
 940   3              case (key_continue):
 941   3              {
 942   4                  Key_Ent_flag = on;
 943   4                  if (set_flag == 0) // 非设置界面
 944   4                  {
 945   5                      air_key_data += 10;
 946   5                      if (air_key_data > 500)
 947   5                          air_key_data = 500;
 948   5                      Disp_Number_Air = DISP_SETTEMP;
 949   5                      Disp_Renew_Flag_Air = on;
 950   5                      Cycle_Times_Disp_Air = 0x00;
 951   5                      key_out_time = 0x30;
 952   5                  }
 953   4              }
 954   3              break;
 955   3              default:
 956   3                  break;
 957   3              }
 958   2          }
 959   1          else if (inkey_number == key_air_down)
 960   1          {
 961   2              switch (key_value)
 962   2              {
 963   3              case (keydown_ent):
 964   3                  break;
 965   3              case (keyup_ent):
 966   3              {
 967   4                  Key_Ent_flag = on;
 968   4                  if (set_flag == 0) // 非设置界面
 969   4                  {
 970   5                      air_key_data--;
 971   5                      if (air_key_data < 100)
 972   5                          air_key_data = 100;
 973   5                      Disp_Number_Air = DISP_SETTEMP;
 974   5                      Disp_Renew_Flag_Air = on;
 975   5                      Cycle_Times_Disp_Air = 0x00;
 976   5                      key_out_time = 0x30;
 977   5                  }
 978   4                  else
 979   4                  {
 980   5                      First_menu_number--;
 981   5                      if (First_menu_number < 0)
 982   5                          First_menu_number = 6;
 983   5                                      if(First_menu_number == 1)
 984   5                                      {
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 17  

 985   6                                              if(CF_flag == 1 || set_cf_flag == 1)
 986   6                                                      air_set_cal_data = (Air_set_temp_data * 9 / 5) + 32;
 987   6                                              else if(CF_flag == 0 || set_cf_flag == 0)
 988   6                                                      air_set_cal_data = Air_set_temp_data;
 989   6                                      }
 990   5                                      if(First_menu_number == 2)
 991   5                                      {
 992   6                                              if(CF_flag == 1 || set_cf_flag == 1)
 993   6                                                      sol_set_cal_data = (Sol_set_temp_data * 9 / 5) + 32;
 994   6                                              else if(CF_flag == 0 || set_cf_flag == 0)
 995   6                                                      sol_set_cal_data = Sol_set_temp_data;
 996   6                                      }
 997   5                      key_out_time = 0x50;
 998   5                  }
 999   4                  inkey_number = key_null;
1000   4              }
1001   3              break;
1002   3              case (key_long):
1003   3                  break;
1004   3              case (key_continue):
1005   3              {
1006   4      
1007   4                  Key_Ent_flag = on;
1008   4                  if (set_flag == 0) // 非设置界面
1009   4                  {
1010   5                      air_key_data -= 10;
1011   5                      if (air_key_data < 100)
1012   5                          air_key_data = 100;
1013   5                      Disp_Number_Air = DISP_SETTEMP;
1014   5                      Disp_Renew_Flag_Air = on;
1015   5                      Cycle_Times_Disp_Air = 0x00;
1016   5                      key_out_time = 0x30;
1017   5                  }
1018   4              }
1019   3              break;
1020   3              default:
1021   3                  break;
1022   3              }
1023   2          }
1024   1          else if (inkey_number == key_sol_up)
1025   1          {
1026   2              switch (key_value)
1027   2              {
1028   3              case (keydown_ent):
1029   3                  break;
1030   3              case (keyup_ent):
1031   3              {
1032   4      
1033   4                  Key_Ent_flag = on;
1034   4                  if (set_flag == 0) // 非设置界面
1035   4                  {
1036   5                      sol_key_data++;
1037   5                      if (CF_flag == 0)
1038   5                      {
1039   6                          if (sol_key_data > 450)
1040   6                              sol_key_data = 450;
1041   6                      }
1042   5                      else
1043   5                      {
1044   6                          if (sol_key_data > 842)
1045   6                              sol_key_data = 842;
1046   6                      }
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 18  

1047   5                      Disp_Number_Sol = DISP_SETTEMP;
1048   5                      Disp_Renew_Flag_Sol = on;
1049   5                      Cycle_Times_Disp_Sol = 0x00;
1050   5                      key_out_time = 0x30;
1051   5                  }
1052   4                  else
1053   4                  {
1054   5                      switch (First_menu_number)
1055   5                      {
1056   6                      case OUT:
1057   6                          /* code */
1058   6                          break;
1059   6                      case AIR_COMPENSATION:
1060   6                          air_set_cal_data++;
1061   6                          if (CF_flag == 1)
1062   6                          {
1063   7                              if (air_set_cal_data > 999)
1064   7                                  air_set_cal_data = 999;
1065   7                          }
1066   6                          else
1067   6                          {
1068   7                              if (air_set_cal_data > 600)
1069   7                                  air_set_cal_data = 600;
1070   7                          }
1071   6                          break;
1072   6                      case SOL_COMPENSATION:
1073   6                          sol_set_cal_data++;
1074   6                          if (CF_flag == 1)
1075   6                          {
1076   7                              if (sol_set_cal_data > 999)
1077   7                                  sol_set_cal_data = 999;
1078   7                          }
1079   6                          else
1080   6                          {
1081   7                              if (sol_set_cal_data > 600)
1082   7                                  sol_set_cal_data = 600;
1083   7                          }
1084   6                          break;
1085   6                      case CF_MODE:
1086   6                          set_cf_flag = ~set_cf_flag;
1087   6                          break;
1088   6                      case DISPLAY_MODE:
1089   6                          disp_gate = ~disp_gate;
1090   6                          break;
1091   6                                      case SPEAK_MODE:
1092   6                                              speak_gate = ~speak_gate;
1093   6                                      break;
1094   6                      case SLEEP_TIME:
1095   6                          set_sleep_time++;
1096   6                          if (set_sleep_time > 99)
1097   6                              set_sleep_time = 00;
1098   6                          break;
1099   6                      default:
1100   6                          break;
1101   6                      }
1102   5                      key_out_time = 0x50;
1103   5                  }
1104   4                  inkey_number = key_null;
1105   4              }
1106   3              break;
1107   3              case (key_long):
1108   3                  break;
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 19  

1109   3              case (key_continue):
1110   3              {
1111   4                  Key_Ent_flag = on;
1112   4                  if (set_flag == 0)
1113   4                  {
1114   5                      sol_key_data += 5;
1115   5                      if (CF_flag == 0)
1116   5                      {
1117   6                          if (sol_key_data > 450)
1118   6                              sol_key_data = 450;
1119   6                      }
1120   5                      else
1121   5                      {
1122   6                          if (sol_key_data > 842)
1123   6                              sol_key_data = 842;
1124   6                      }
1125   5                      Disp_Number_Sol = DISP_SETTEMP;
1126   5                      Disp_Renew_Flag_Sol = on;
1127   5                      Cycle_Times_Disp_Sol = 0x00;
1128   5                      key_out_time = 0x30;
1129   5                  }
1130   4                  else
1131   4                  {
1132   5                      switch (First_menu_number)
1133   5                      {
1134   6                      case AIR_COMPENSATION:
1135   6                          air_set_cal_data += 5;
1136   6                          if (CF_flag == 1)
1137   6                          {
1138   7                              if (air_set_cal_data > 1112)
1139   7                                  air_set_cal_data = 1112;
1140   7                          }
1141   6                          else
1142   6                          {
1143   7                              if (air_set_cal_data > 600)
1144   7                                  air_set_cal_data = 600;
1145   7                          }
1146   6                          break;
1147   6                      case SOL_COMPENSATION:
1148   6                          sol_set_cal_data += 5;
1149   6                          if (CF_flag == 1)
1150   6                          {
1151   7                              if (sol_set_cal_data > 1022)
1152   7                                  sol_set_cal_data = 1022;
1153   7                          }
1154   6                          else
1155   6                          {
1156   7                              if (sol_set_cal_data > 550)
1157   7                                  sol_set_cal_data = 550;
1158   7                          }
1159   6                          break;
1160   6                      case SLEEP_TIME:
1161   6                          set_sleep_time += 5;
1162   6                          if (set_sleep_time > 99)
1163   6                              set_sleep_time = 00;
1164   6                          break;
1165   6                      default:
1166   6                          break;
1167   6                      }
1168   5                      key_out_time = 0x50;
1169   5                  }
1170   4              }
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 20  

1171   3              break;
1172   3              default:
1173   3                  break;
1174   3              }
1175   2          }
1176   1          else if (inkey_number == key_sol_down)
1177   1          {
1178   2              switch (key_value)
1179   2              {
1180   3              case (keydown_ent):
1181   3                  break;
1182   3              case (keyup_ent):
1183   3              {
1184   4      
1185   4                  Key_Ent_flag = on;
1186   4                  if (set_flag == 0) // 非设置界面
1187   4                  {
1188   5                      sol_key_data--;
1189   5                      if (CF_flag == 0)
1190   5                      {
1191   6                          if (sol_key_data < 200)
1192   6                              sol_key_data = 200;
1193   6                      }
1194   5                      else
1195   5                      {
1196   6                          if (sol_key_data < 392)
1197   6                              sol_key_data = 392;
1198   6                      }
1199   5                      Disp_Number_Sol = DISP_SETTEMP;
1200   5                      Disp_Renew_Flag_Sol = on;
1201   5                      Cycle_Times_Disp_Sol = 0x00;
1202   5                      key_out_time = 0x30;
1203   5                  }
1204   4                  else
1205   4                  {
1206   5                      switch (First_menu_number)
1207   5                      {
1208   6                      case OUT:
1209   6                          /* code */
1210   6                          break;
1211   6                      case AIR_COMPENSATION:
1212   6                          air_set_cal_data--;
1213   6                          if (CF_flag == 1)
1214   6                          {
1215   7                              if (air_set_cal_data < 34)
1216   7                                  air_set_cal_data = 34;
1217   7                          }
1218   6                          else
1219   6                          {
1220   7                              if (air_set_cal_data < 1)
1221   7                                  air_set_cal_data = 1;
1222   7                          }
1223   6                          break;
1224   6                      case SOL_COMPENSATION:
1225   6                          sol_set_cal_data--;
1226   6                          if (CF_flag == 1)
1227   6                          {
1228   7                              if (sol_set_cal_data > 212)
1229   7                                  sol_set_cal_data = 212;
1230   7                          }
1231   6                          else
1232   6                          {
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 21  

1233   7                              if (sol_set_cal_data > 100)
1234   7                                  sol_set_cal_data = 100;
1235   7                          }
1236   6                          break;
1237   6                      case CF_MODE:
1238   6                          set_cf_flag = ~set_cf_flag;
1239   6                                              
1240   6                          break;
1241   6                      case DISPLAY_MODE:
1242   6                          disp_gate = ~disp_gate;
1243   6                          break;
1244   6                                      case SPEAK_MODE:
1245   6                                              speak_gate = ~speak_gate;
1246   6                                      break;
1247   6                      case SLEEP_TIME:
1248   6                          set_sleep_time--;
1249   6                          if (set_sleep_time < 0)
1250   6                              set_sleep_time = 0;
1251   6                          break;
1252   6                      default:
1253   6                          break;
1254   6                      }
1255   5                      key_out_time = 0x50;
1256   5                  }
1257   4      
1258   4                  inkey_number = key_null;
1259   4              }
1260   3              break;
1261   3              case (key_long):
1262   3                  break;
1263   3              case (key_continue):
1264   3              {
1265   4                  Key_Ent_flag = on;
1266   4                  if (set_flag == 0)
1267   4                  {
1268   5                      sol_key_data -= 5;
1269   5                      if (CF_flag == 0)
1270   5                      {
1271   6                          if (sol_key_data < 200)
1272   6                              sol_key_data = 200;
1273   6                      }
1274   5                      else
1275   5                      {
1276   6                          if (sol_key_data < 392)
1277   6                              sol_key_data = 392;
1278   6                      }
1279   5                      Disp_Number_Sol = DISP_SETTEMP;
1280   5                      Disp_Renew_Flag_Sol = on;
1281   5                      Cycle_Times_Disp_Sol = 0x00;
1282   5                      key_out_time = 0x30;
1283   5                  }
1284   4                  else
1285   4                  {
1286   5                      switch (First_menu_number)
1287   5                      {
1288   6                      case AIR_COMPENSATION:
1289   6                          air_set_cal_data -= 5;
1290   6                          if (CF_flag == 1)
1291   6                          {
1292   7                              if (air_set_cal_data < 34)
1293   7                                  air_set_cal_data = 34;
1294   7                          }
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 22  

1295   6                          else
1296   6                          {
1297   7                              if (air_set_cal_data < 1)
1298   7                                  air_set_cal_data = 1;
1299   7                          }
1300   6                          break;
1301   6                      case SOL_COMPENSATION:
1302   6                          sol_set_cal_data -= 5;
1303   6                          if (CF_flag == 1)
1304   6                          {
1305   7                              if (sol_set_cal_data < 212)
1306   7                                  sol_set_cal_data = 212;
1307   7                          }
1308   6                          else
1309   6                          {
1310   7                              if (sol_set_cal_data < 100)
1311   7                                  sol_set_cal_data = 100;
1312   7                          }
1313   6                          break;
1314   6                      case SLEEP_TIME:
1315   6                          set_sleep_time -= 5;
1316   6                          if (set_sleep_time < 0)
1317   6                              set_sleep_time = 00;
1318   6                          break;
1319   6                      default:
1320   6                          break;
1321   6                      }
1322   5                      key_out_time = 0x50;
1323   5                  }
1324   4              }
1325   3              break;
1326   3              default:
1327   3                  break;
1328   3              }
1329   2          }
1330   1          else if (Key_Ent_flag == on && key_out_time == 0x00)
1331   1          {
1332   2              if (set_flag == 1)
1333   2              {
1334   3                  set_flag = 0;
1335   3                              CF_flag = set_cf_flag;
1336   3                  if (CF_flag == 1)
1337   3                  {
1338   4                                      sol_key_data = (Sol_set_temp_data * 9 / 5) + 32;
1339   4                                      air_key_data = (Air_set_temp_data * 9 / 5) + 32;
1340   4                      Air_cal_data = Air_set_temp_data - (5 * (air_set_cal_data - 32) / 9);
1341   4                      Sol_cal_data = Sol_set_temp_data - (5 * (sol_set_cal_data - 32) / 9);
1342   4                  }
1343   3                  else
1344   3                  {
1345   4                                      sol_key_data = Sol_set_temp_data;
1346   4                                      air_key_data = Air_set_temp_data;
1347   4                      Air_cal_data = Air_set_temp_data - air_set_cal_data;
1348   4                      Sol_cal_data = Sol_set_temp_data - sol_set_cal_data;
1349   4                  }
1350   3                  
1351   3              }
1352   2                      else 
1353   2                      {
1354   3                              pid_mode_air = 0;
1355   3                              pid_mode_sol = 0;
1356   3                              PID_Init_Air();
C51 COMPILER V9.60.7.0   MAIN                                                              08/28/2025 16:11:08 PAGE 23  

1357   3                              PID_Init_Sol();
1358   3                      }
1359   2                      if(CF_flag == 1)
1360   2                      {
1361   3                              Sol_set_temp_data = (5 * (sol_key_data - 32) / 9);
1362   3                              Air_set_temp_data = (5 * (air_key_data - 32) / 9);
1363   3                      }
1364   2                      else 
1365   2                      {
1366   3                               Sol_set_temp_data = sol_key_data;
1367   3                               Air_set_temp_data = air_key_data;
1368   3                      }
1369   2              Disp_Renew_Flag_Air = on;
1370   2              Cycle_Times_Disp_Air = 0x00;
1371   2              Disp_Renew_Flag_Sol = on;
1372   2              Cycle_Times_Disp_Sol = 0x00;
1373   2              Disp_Renew_Flag_Fan = on;
1374   2              Save_Data_Handle();
1375   2              Key_Ent_flag = off;
1376   2          }
1377   1      }
1378          
1379          void Save_Data_Handle(void)
1380          {
1381   1          u8_data[0] = CF_flag;
1382   1          u8_data[2] = disp_gate;
1383   1              u8_data[3] = speak_gate;
1384   1          wd16z8(Air_cal_data, 4);
1385   1          wd16z8(Sol_cal_data, 6);
1386   1          wd16z8(Air_set_temp_data, 8);
1387   1          wd16z8(Sol_set_temp_data, 10);
1388   1          wd16z8(set_sleep_time, 12);
1389   1              wd16z8(Air_speed_data,14);
1390   1          ISPpagewrite(u8_data);
1391   1      }
1392          
1393          void wd16z8(uint16_t in_16data, uint8_t wn) // 8?????:
1394          {
1395   1          u8_data[wn] = in_16data >> 8;
1396   1          u8_data[wn + 1] = in_16data;
1397   1      }
1398          
1399          uint16_t rd8z16(uint8_t rdin_i)
1400          {
1401   1          uint16_t bit16_data = 0;
1402   1          bit16_data = u8_data[rdin_i];
1403   1          bit16_data <<= 8;
1404   1          bit16_data |= u8_data[rdin_i + 1];
1405   1          return (bit16_data);
1406   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6012    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     50    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
